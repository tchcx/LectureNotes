
#!/usr/bin/env bash

#
# Password Mutator
# Takes a list of common passwords from input file(s) and generates variations.
# This uses a pipeline and deduplication between stages to remain efficient-ish.
#

# Swap characters
swap_first_letter_cap() {
  local first_letter rest_of_word
  first_letter=$(echo "${1:0:1}" | tr '[:upper:][:lower:]' '[:lower:][:upper:]')
  rest_of_word="${1:1}"
  echo "$first_letter$rest_of_word"
}

# Converts a word to all uppercase.
all_upper() {
  echo "$1" | tr '[:lower:]' '[:upper:]'
}

# Converts a word to all lowercase.
all_lower() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

# Substitutes 'e' or 'E' with '3'.
leet_speak_e_to_3() {
  echo "$1" | tr 'Ee' '33'
}

# Substitutes 'a' or 'A' with '@'.
leet_speak_a_to_at() {
  echo "$1" | tr 'aA' '@@'
}

# Substitutes 'o' or 'O' with '0'.
leet_speak_o_to_0() {
  echo "$1" | tr 'oO' '00'
}

# Substitutes 's' or 'S' with '$'.
leet_speak_s_to_dollar() {
  echo "$1" | tr 'sS' '$$'
}

# Applies various capitalization mutations.
apply_capitalization_mutations() {
  while read -r pw; do
    echo "$pw"
    swap_first_letter_cap "$pw"
    all_upper "$pw"
    all_lower "$pw"
    all_upper "$pw" | swap_first_letter_cap
    all_lower "$pw" | swap_first_letter_cap
  done
}

# Applies leet mutations.
apply_leet_speak_mutations() {
  while read -r pw; do
    echo "$pw" # Output the original password
    # Single substitutions
    leet_speak_s_to_dollar "$pw"
    leet_speak_a_to_at "$pw"
    leet_speak_e_to_3 "$pw"
    leet_speak_o_to_0 "$pw"
    # Combined substitutions
    leet_speak_a_to_at "$pw" | leet_speak_s_to_dollar
    leet_speak_e_to_3 "$pw" | leet_speak_s_to_dollar
    leet_speak_o_to_0 "$pw" | leet_speak_s_to_dollar
    leet_speak_a_to_at "$pw" | leet_speak_e_to_3
    leet_speak_a_to_at "$pw" | leet_speak_o_to_0
    leet_speak_e_to_3 "$pw" | leet_speak_o_to_0
    leet_speak_a_to_at "$pw" | leet_speak_e_to_3 | leet_speak_o_to_0
    leet_speak_a_to_at "$pw" | leet_speak_e_to_3 | leet_speak_s_to_dollar
    leet_speak_a_to_at "$pw" | leet_speak_o_to_0 | leet_speak_s_to_dollar
    leet_speak_e_to_3 "$pw" | leet_speak_o_to_0 | leet_speak_s_to_dollar
    leet_speak_a_to_at "$pw" | leet_speak_e_to_3 | leet_speak_o_to_0 | leet_speak_s_to_dollar
  done
}

# Prepends common prefixes.
apply_prefixes() {
  while read -r pw; do
    echo "$pw"
    echo "My$pw"
    echo "my$pw"
    echo "MY$pw"
    echo "The$pw"
    echo "the$pw"
    echo "THE$pw"
    echo "A$pw"
    echo "a$pw"
    echo "An$pw"
    echo "an$pw"
    echo "AN$pw"
  done
}

# Appends common suffixes.
apply_suffixes() {
  while read -r pw; do
    echo "$pw"
    echo "$pw!"
    echo "$pw!!"
    echo "$pw!!!"
    echo "$pw?"
  done
}

# Appends digits 0-9, but only to passwords that do not already end in a number.
apply_conditional_numeric_suffix() {
  while IFS= read -r pw; do
    # First, pass through the original password regardless.
    echo "$pw"

    # Now, check if the password does NOT end in a number.
    # The 'if !' statement succeeds if the grep command fails to find a match.
    if ! echo "$pw" | grep -q '[0-9]$'; then
      # If it doesn't end in a number append 0. 1-9 will be gotten by digit rotations.
        echo "${pw}0"
    fi
  done
}

# Appends conditional short and long year, when not already ending in number
apply_conditional_year_suffix() {
  local current_year_long current_year_short
  current_year_long=$(date +'%Y')
  current_year_short=$(date +'%y')

  while IFS= read -r pw; do
    # First, pass through the original password regardless.
    echo "$pw"

    # Now, check if the password does NOT end in a number.
    # The 'if !' statement succeeds if the grep command fails to find a match.
    if ! echo "$pw" | grep -q '[0-9]$'; then
      # If it doesn't end in a number append years.
        echo "$pw$((current_year_long - 2))" # e.g., 2023
        echo "$pw$((current_year_long - 1))" # e.g., 2024
        echo "$pw$current_year_long"         # e.g., 2025
        echo "$pw$((current_year_short - 2))" # e.g., 23
        echo "$pw$((current_year_short - 1))" # e.g., 24
        echo "$pw$current_year_short"         # e.g., 25
    fi
  done
}

# Rotates digits within passwords, including reversed rotations.
apply_digit_rotations() {
  # Generate digit rotation maps
  local rotate_digits=()
  for i in {0..9}; do
    local string_forward=""
    # Create the forward-rotating map (e.g., 1234567890)
    for j in {0..9}; do
      string_forward+="$(((i + j) % 10))"
    done
    # Add the forward map
    rotate_digits+=("$string_forward")
    # Add the reverse of that map (e.g., 0987654321) using rev
    rotate_digits+=("$(echo "$string_forward" | rev)")
  done

  # Read all passwords from stdin into an array.
  local pws_in=()
  while IFS= read -r line; do
    pws_in+=("$line")
  done

  # Iterate over the passwords for each of the 20 rotation maps.
  for pw in "${pws_in[@]}"; do
    echo "$pw" # Output the original password
    for map in "${rotate_digits[@]}"; do
      echo "$pw" | tr "0123456789" "$map"
    done
  done
}


main() {
  # Check if file arguments were provided.
  if [[ $# -eq 0 ]]; then
    echo "Usage: $0 <file1> [file2] ..." >&2
    echo "Error: Please provide at least one input file." >&2
    exit 1
  fi

  # Use a temporary file to store the final output.
  local tmp_file
  tmp_file=$(mktemp)

  # Count the number of input passwords.
  # Using process substitution with cat to avoid issues with special characters in filenames
  local input_count
  input_count=$(cat "$@" | wc -l)

  # The main mutation pipeline.
  # It now reads from the file arguments and writes to the temporary file.
  cat "$@" | \
    apply_capitalization_mutations    | sort -u | \
    apply_conditional_numeric_suffix  | sort -u | \
    apply_digit_rotations             | sort -u | \
    apply_leet_speak_mutations        | sort -u | \
    apply_conditional_year_suffix     | sort -u | \
    apply_prefixes                    | sort -u | \
    apply_suffixes                    | sort -u > "$tmp_file"

  # Count the unique output passwords from the temporary file.
  local output_count
  output_count=$(wc -l < "$tmp_file")

  # Calculate the expansion ratio using awk for floating-point math.
  local expansion_ratio
  expansion_ratio=$(awk "BEGIN {printf \"%.2f\", $output_count / $input_count}")

  # Print the final list of passwords to standard output.
  cat "$tmp_file"

  # Clean up the temporary file.
  rm "$tmp_file"

  # Print the statistics to standard error.
  echo "---" >&2
  echo "âœ… Done." >&2
  echo "Input Passwords:  $input_count" >&2
  echo "Output Passwords: $output_count" >&2
  echo "Expansion Ratio:  ${expansion_ratio}x" >&2
}

# Execute the main function with all command-line arguments.
main "$@"
