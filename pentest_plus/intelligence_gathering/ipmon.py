#!/usr/bin/env python3

"""
ufw_vt_checker.py

This script parses a UFW (Uncomplicated Firewall) log file to find
IP addresses that were blocked trying to access a specific port (default 22).
It then queries the VirusTotal API v3 to check the reputation of each unique IP.
IPs flagged as malicious by one or more security vendors are saved to an output file.

Requires:
- Python 3.6+
- 'requests' library (install with: pip install requests)
- A VirusTotal API key.

Usage:
1. Get your VirusTotal API key from your VT account.
2. Set the API key as an environment variable:
   export VT_API_KEY="your_api_key_here"
3. Run the script with sudo (to access /var/log/ufw.log):
   sudo python3 ufw_vt_checker.py --log-file /var/log/ufw.log --output-file malicious_ips.txt

Note:
The free VirusTotal API has a strict rate limit (e.g., 4 requests per minute).
This script respects that limit by sleeping for 16 seconds between each API call,
so it may take a long time to run if you have many unique IPs.
"""

import re
import os
import sys
import time
import requests
import argparse
import ipaddress
from typing import Set, Optional, Dict, Any



# VirusTotal API v3 endpoint for IP addresses
VT_API_URL = "https://www.virustotal.com/api/v3/ip_addresses/{}"

# Regex to find UFW BLOCK lines for a specific port
# This looks for "[UFW BLOCK]", "SRC=" (capturing the IP), and "DPT=" (capturing the port)
UFW_LOG_REGEX = re.compile(r"\[UFW BLOCK\].*SRC=([\d\.]+).*DPT=(\d+)")

# Free API has a 4 reqs/min limit. 60s / 4 = 15s. We'll use 16s to be safe.
VT_API_SLEEP_SECONDS = 16



def is_private_ip(ip: str) -> bool:
    """Checks if an IP address is in a private range (e.g., 192.168.x.x)."""
    try:
        return ipaddress.ip_address(ip).is_private
    except ValueError:
        # Invalid IP format, treat as something not to check
        return True

def get_vt_api_key() -> Optional[str]:
    """Retrieves the VirusTotal API key from an environment variable."""
    api_key = os.environ.get("VT_API_KEY")
    if not api_key:
        print(
            "Error: VT_API_KEY environment variable not set.",
            file=sys.stderr
        )
        print(
            "Please set it first: export VT_API_KEY='your_key_here'",
            file=sys.stderr
        )
    return api_key

def parse_ufw_log(log_file_path: str, port: int) -> Set[str]:
    """
    Parses the UFW log file and returns a set of unique, public IP addresses
    that were blocked on the specified port.
    """
    print(f"Parsing log file: {log_file_path} for blocks on port {port}...")
    unique_ips: Set[str] = set()
    
    try:
        with open(log_file_path, "r") as f:
            for line in f:
                match = UFW_LOG_REGEX.search(line)
                # Check if we have a match and if the port matches our target
                if match and int(match.group(2)) == port:
                    ip = match.group(1)
                    # Add to set if it's not a private IP
                    if not is_private_ip(ip):
                        unique_ips.add(ip)
                        
    except FileNotFoundError:
        print(f"Error: Log file not found at {log_file_path}", file=sys.stderr)
        return set()
    except PermissionError:
        print(
            f"Error: Permission denied for {log_file_path}.",
            file=sys.stderr
        )
        print("Hint: You probably need to run this script with 'sudo'.", file=sys.stderr)
        return set()
    except Exception as e:
        print(f"An error occurred while reading the log file: {e}", file=sys.stderr)
        return set()

    print(f"Found {len(unique_ips)} unique public IPs.")
    return unique_ips

def check_ip_virustotal(ip: str, api_key: str) -> Optional[Dict[str, Any]]:
    """
    Queries the VirusTotal API for a single IP address and returns its
    analysis statistics. Returns None on error.
    """
    headers = {"x-apikey": api_key}
    url = VT_API_URL.format(ip)
    
    try:
        response = requests.get(url, headers=headers)
        
        if response.status_code == 200:
            return response.json().get("data", {}).get("attributes", {})
        elif response.status_code == 404:
            print(f"  -> IP {ip} not found in VirusTotal.")
            return None
        elif response.status_code == 401:
            print("  -> Error: Invalid VirusTotal API key.", file=sys.stderr)
            # This is a fatal error, so we'll signal to stop
            raise SystemExit("Invalid API Key. Exiting.")
        else:
            print(
                f"  -> Error querying VT for {ip}:"
                f"HTTP {response.status_code} - {response.text}",
                file=sys.stderr
            )
            return None
            
    except requests.RequestException as e:
        print(f"  -> Network error checking {ip}: {e}", file=sys.stderr)
        return None
    except SystemExit:
        # Re-raise the exit signal to stop the script
        raise
    except Exception as e:
        print(f"  -> An unknown error occurred: {e}", file=sys.stderr)
        return None



def main():
    """Main function to parse args and run the checker."""
    parser = argparse.ArgumentParser(
        description="Check UFW blocked IPs against VirusTotal."
    )
    parser.add_argument(
        "-l",
        "--log-file",
        default="/var/log/ufw.log",
        help="Path to the UFW log file (default: /var/log/ufw.log)"
    )
    parser.add_argument(
        "-o",
        "--output-file",
        default="malicious_ips.txt",
        help="File to save malicious IPs to (default: malicious_ips.txt)"
    )
    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=22,
        help="The destination port to filter for (default: 22)"
    )
    parser.add_argument(
        "-t",
        "--threshold",
        type=int,
        default=1,
        help=(
            "Minimum number of 'malicious' votes to be flagged "
            "(default: 1)"
        )
    )
    
    args = parser.parse_args()

    # 1. Get API Key
    api_key = get_vt_api_key()
    if not api_key:
        sys.exit(1)

    # 2. Parse Log File
    unique_ips = parse_ufw_log(args.log_file, args.port)
    if not unique_ips:
        print("No IPs found to check. Exiting.")
        return

    # 3. Check IPs against VirusTotal
    print(
        f"\nStarting VirusTotal check for {len(unique_ips)} IPs."
    )
    print(
        f"This will take approximately "
        f"{len(unique_ips) * VT_API_SLEEP_SECONDS / 60:.1f} minutes."
    )
    
    malicious_ips = []
    
    try:
        for i, ip in enumerate(unique_ips):
            print(f"Checking IP {i+1}/{len(unique_ips)}: {ip}")
            
            attributes = check_ip_virustotal(ip, api_key)
            
            if attributes:
                stats = attributes.get("last_analysis_stats", {})
                malicious_votes = stats.get("malicious", 0)
                
                if malicious_votes >= args.threshold:
                    report = (
                        f"IP: {ip}, "
                        f"Malicious: {malicious_votes}, "
                        f"Suspicious: {stats.get('suspicious', 0)}, "
                        f"VT Link: https://www.virustotal.com/gui/ip-address/{ip}"
                    )
                    print(f"  -> !!! MALICIOUS FOUND !!!: {report}")
                    malicious_ips.append(report)
                else:
                    print(f"  -> Clean/Suspicious (Malicious: {malicious_votes})")

            # Wait to respect API rate limits, even if the last check failed
            if i < len(unique_ips) - 1:
                print(f"  -> Sleeping for {VT_API_SLEEP_SECONDS} seconds...")
                time.sleep(VT_API_SLEEP_SECONDS)
                
    except SystemExit:
        # This handles the "Invalid API Key" exit
        print("Stopping script due to API key error.", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nUser interrupt detected. Stopping script.")
        # We'll still try to save whatever we found so far
        pass

    # 4. Save results
    if malicious_ips:
        try:
            with open(args.output_file, "w") as f:
                for line in malicious_ips:
                    f.write(line + "\n")
            print(
                f"\nSuccessfully saved {len(malicious_ips)} "
                f"malicious IP reports to {args.output_file}"
            )
        except Exception as e:
            print(
                f"\nError writing to output file {args.output_file}: {e}",
                file=sys.stderr
            )
    else:
        print("\nNo malicious IPs found matching the criteria.")

if __name__ == "__main__":
    main()
